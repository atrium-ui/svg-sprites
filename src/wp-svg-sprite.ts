import { buildSprite, SVGSpriteOptions } from "./svg-sprite";
import { name } from "../package.json";

export default class SvgSprite {
  static defaultOptions: SVGSpriteOptions = {
    dir: "assets/icons/*.svg",
  };

  options: SVGSpriteOptions;

  // Any options should be passed in the constructor of your plugin,
  // (this is a public API of your plugin).
  constructor(options: SVGSpriteOptions = SvgSprite.defaultOptions) {
    // Applying user-specified options over the default options
    // and making merged options further available to the plugin methods.
    // You should probably validate all the options here as well.
    this.options = { ...options };
  }

  apply(compiler: any) {
    const pluginName = SvgSprite.name;

    // webpack module instance can be accessed from the compiler object,
    // this ensures that correct version of the module is used
    // (do not require/import the webpack or any symbols from it directly).
    const { webpack } = compiler;

    // Compilation object gives us reference to some useful constants.
    const { Compilation } = webpack;

    // RawSource is one of the "sources" classes that should be used
    // to represent asset sources in compilation.
    const { RawSource } = webpack.sources;

    // Tapping to the "thisCompilation" hook in order to further tap
    // to the compilation process on an earlier stage.
    compiler.hooks.thisCompilation.tap(pluginName, (compilation: any) => {
      // Tapping to the assets processing pipeline on a specific stage.
      compilation.hooks.processAssets.tap(
        {
          name: pluginName,

          // Using one of the later asset processing stages to ensure
          // that all assets were already added to the compilation by other plugins.
          stage: Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE,
        },
        (assets: any) => {
          // "assets" is an object that contains all assets
          // in the compilation, the keys of the object are pathnames of the assets
          // and the values are file sources.

          // Iterating over all the assets and
          // generating content for our Markdown file.
          const content =
            "# In this build:\n\n" +
            Object.keys(assets)
              .map((filename) => `- ${filename}`)
              .join("\n");

          // Adding new asset to the compilation, so it would be automatically
          // generated by the webpack in the output directory.
          compilation.emitAsset("assets.md", new RawSource(content));
        }
      );
    });
  }

  // svgSprite(options: SVGSpriteOptions = { dir: "assets/icons/*.svg" }) {
  //   const svg = buildSprite(options);

  //   const virtualId = "~svg-sprite";

  //   let importId: string | null;

  //   return {
  //     name: "svg-sprite",
  //     enforce: "pre",

  //     async resolveId(source, importer, options) {
  //       if (source.match(name + "/component")) {
  //         const resolved = await this.resolve(source, importer, { skipSelf: true, ...options });
  //         if (resolved && !resolved.external) {
  //           importId = resolved ? resolved.id : null;
  //           return importId;
  //         }
  //       }
  //       if (source === virtualId) {
  //         return source;
  //       }
  //     },

  //     async load(id) {
  //       if (id === virtualId) {
  //         return `
  //           export default new Blob([\`${await svg}\`], { type: "image/svg+xml" });
  //         `;
  //       }
  //     },

  //     async transform(code, id) {
  //       if (id === importId) {
  //         return {
  //           code: code.replace(
  //             /"_svgSheetBlob_"/g,
  //             `new Blob([\`${await svg}\`], { type: "image/svg+xml" });`
  //           ),
  //         };
  //       }
  //       return null;
  //     },
  //   };
  // }
}
